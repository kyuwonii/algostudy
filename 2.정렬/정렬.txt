2. 정렬
C++에서 라이브러리로 제공하는 정렬 알고리즘은 오름차순 정렬
참고 : https://hsp1116.tistory.com/33 -> 여기 정렬을 움짤로 설명해 놨는데 이해가 잘돼요!

정렬 알고리즘 
n개의 숫자가 입력으로 주어졌을 때, 사용자의 기준에 맞게 정렬하여 출력하는 알고리즘
시간 복잡도는 n제곱, n로그n정도의 알고리즘이 가장 보편적이다.

1.	선택 정렬 : 시간 복잡도 엔제곱
현재 위치에 들어갈 값을 찾아서 정려라는 배열.
-	정렬되지 않은 인덱스의 맨 앞에서 배열 중 가장 작은 값을 찾아간다.
-	가장 작은 값을 찾으면, 그 값을 현재 인덱스 값과 바꿔준다.
-	이와 같은 과정 반복 
-	C++ 코드 예시
-	void selectionSort(vector<int> v){
-	    for(int i=0; i<v.size()-1; i++){
-	        int tmp = i;
-	        for(int j=i+1; j<v.size(); j++){
-	            if(v[tmp]>=v[j]) tmp = j;
-	        }
-	        swap(v[i], v[tmp]);
-	    }
-	}


2.	삽입 정렬
현재 위치에서, 이후 배열들을 비교하여 자신이 들어갈 위치를 찾아, 그 위치에 삽입하는 배열 알고리즘.
-두번째 인덱스부터 시작. 별도의 변수에 저장하고, 비교 인덱스는 현재 인덱스 -1로 잡음
- 별도로 저장해 둔 삽입을 위한 변수와, 비교 인덱스의 배열 값을 비교한다.
- 삽입변수의 값이 더 작으면 현재 인덱스로 비교 인덱스의 값을 저장, 비교 인덱스를 -1 하여 비교를 반복한다.
- 만일 삽입변수가 더 크면, 비교 인덱스 +1 에 삽이 변수를 저장한다.

최악의 경우 시간 복잡도 엔제곱
void insertionSort(vector<int> v){
    for(int i=1 ; i<v.size(); i++){
        int key = v[i], j = i-1;
            while(j<=0 && key<v[j]){
                v[j+1]=v[j];
                j--;
            }
            v[j+1] = key;
    }
}

3.	버블 정렬
매번 연속된 두개의 인덱스를 비교, 정한 기준의 값을 뒤로 넘겨 정렬
오름차순으로 정렬, 큰 값이 뒤로 이동하여, 한바퀴 돌면 걔가 가장 큰 값.
n-1비교?
-	두번째 인덱스부터 시작, 현대 인덱스 값과 바로 이전의 인덱스 값 비교
-	이전 인덱스가 더 크면, 현재 인덱스와 바꿔준다.
-	현재 인덱스가 더 크면, 교환하지 않고 다음 두 연속된 배열값을 비교
-	이를 전체 배열의 크기 – 순환한 바퀴 수( 앞에 해결된 개수) 반복.
-	시간 복잡도 엔 제곱
-	void bubbleSort(<vector<int> v){
-	    for(int i=0; i<v.size()-1; i++){
-	        for(int j=1; j<v.size()-i;j++){
-	            if(v[j-1] > v[j]){
-	                swap(v[j-1], v[j]);
-	            }
-	        }
-	    }
-	}
4.	합병 정렬
분할 정복 방식으로 설계 (큰 문제를 반으로 쪼개 문제를 해결)
배열의 크기가 1보다 작거나 같을 때까지 반복.
입력으로 하나의 배열을 받고, 연산 중에 두개의 배열로 쪼개기, 나중에 합치면서 최후의 하나의 정렬을 출력

합병은 두개의 배열을 비교, 기준에 맞는 값을 다른 배열에 저장한다.
A나 b중 하나가 모든 배열값을 새 배열에 저장할 때까지 비교 저장을 반복하고, 다 저장하지 못한 배열값들은 모두 새 배열의 값에 저장.

분할 
-	현재 배열을 반으로 쪼갠다. 시작 위치와 종료위치를 더하고 반으로 나눠서 기준.
-	쪼갠 배열의 크기가 0이나 1일 때까지 반복한다.

합병
-	두 배열의 크기를 비교한다. I,j
-	i에는 시작 인덱스, j에는 두번째 배열의 시작 주소를 저장한다.
-	둘을 비교한다. 오름차순일 경우 이중에 작은 값을 새 배열에 저장한다.
-	그 뒤에 더 컸던 쪽 인덱스를 하나 증가시켜 준다.
-	I나 j 둘중 하나가 각자 배열의 끝에 도달할 때 까지 반복한다.
-	끝까지 저장을 못한 배열의 값을, 순서대로 전부 다 새 배열에 저장한다.
-	새로 생긴 배열을 원래의 배열에 저장해준다.
-	시간 복잡도는 n로그n
-	void merge(vector<int& v, int s, int e, int m){
-	    vector<int> ret;
-	    int i = s, j = m+1, copy = 0;
-	
-	    // 비교 저장
-	    while(i <= m && j<=e) {
-	        if (v[i] < v[j]) ret.pushback(v[i++]);
-	        else  if (v[i] > v[j]) ret.pushback(v[j++]);
-	    }
-	
-	    //남은거 채워주기
-	    while (i <= m) ret.pushback(v[i++]);
-	    while (j <= e) ret.pushback(v[j++]);
-	
-	    //원래 배열에 저장
-	    for (int k = s; k<=e; k++) {
-	        v[k] = ret[copy++];
-	    }
-	
-	}
-	
-	void mergeSort(vector<int>& v, int s, int e){
-	    if(s<e){
-	        int m = (s+e)/2;
-	        mergeSort(v,s,m); //분할
-	        mergeSort(v,m+1,e);
-	
-	        merge(v,s,e,m;) // 합병
-	    }
-	}

5.	퀵정렬
분할 정복 이용하여 정렬을 수행하는 알고리즘
Pivot point라는 기준이 되는 값을 설정하여, 이 값을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽으로 정렬을 진행한다.
분할된 배열의 크기가 1이 되면 배열이 정렬된 것이다.
-	Pp로 정할 배열의 값을 하나 정한다. 
-	비교를 정하기 위해 가장 왼쪽 인덱스를 저장한 레프트,. 그반대의 라이트를 설정한다.
-	right부터 비교를 진행한다. 비교는 right가 left보다 클 때만 반복하며, 비교한 배열 값이 pivot point보다 크면 right 하나 감소시키고 비교를 반복한다. PP보다 큰 배열 값을 찾으면 반복을 중지한다.
-	34,5 과정을 레프트가 라이트보다 클 때까지 한다.
-	위 과정이 끝나면 LEFT와 PP를 바꿔준다.
-	맨 왼쪽부터 LEFT-1까지, 그 나머지로 나눠서 퀵 정렬을 반복한다.
-	시간 복잡도 N로그N
-	void qsort(vector<int>& v, int s, int e) {
-	    int pivot = v[s];
-	    int bs = s, be = e;
-	    while (s<e) {
-	        while( pivot <= v[e] && s<e) e--;
-	        if (s<e) break;
-	        while( pivot >= v[s] && s<e) s++;
-	        if (s>e) break;
-	        std::swap(v[s], v[e]);
-	    }
-	    std::swap(v[bs],v[s]);
-	    if(bs<s)
-	        qsort(v,bs,s-1);
-	    if(be>e)
-	        qsort(v,s+1,be);
-	}

